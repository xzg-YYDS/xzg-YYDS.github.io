<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    
    Hexo
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-前端面试题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    

    
    <div class="article-meta">
      <a href="/2023/01/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2023-01-08T07:36:08.749Z" itemprop="datePublished">2023-01-08</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="前端面试题"><a href="#前端面试题" class="headerlink" title="前端面试题"></a>前端面试题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).<span class="property">css</span>中各单位的区别</span><br><span class="line"><span class="number">1</span> 、px</span><br><span class="line">px就是pixel（像素）的缩写，相对长度单位，相对于屏幕分辨率。</span><br><span class="line"><span class="number">2</span>、em</span><br><span class="line">参考物是父元素的font-size，具有继承的特点。浏览器默认字体是16px，整个页面内1em不是一个固定的值。</span><br><span class="line"><span class="number">3</span>、rem</span><br><span class="line">rem是<span class="title class_">CSS3</span>新增的一个相对单位，但相对的只是<span class="variable constant_">HTML</span>根元素。通过它既可以做到只修改根元素就成比例地调整所有字体大小.</span><br><span class="line"><span class="number">4</span>、%</span><br><span class="line">% 百分比，相对长度单位，相对于父元素的百分比值，使用时必须从根容器就设置好百分比</span><br><span class="line"><span class="number">5</span>、vw和vh</span><br><span class="line">vm、vh、vmin、vmax是一种视窗单位，也是相对单位。它相对的不是父节点或者页面的根节点。而是由视窗（<span class="title class_">Viewport</span>）大小来决定的，单位 <span class="number">1</span>，代表类似于 <span class="number">1</span>%。 视窗(<span class="title class_">Viewport</span>)是你的浏览器实际显示内容的区域，换句话说是你的网页浏览器不包括工具栏和按钮的部分。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>).<span class="property">flex</span>的复合属性</span><br><span class="line">flex 指的是flex-grow,flex-shrink,flex-basis3个属性结合在一起的缩写形式。</span><br><span class="line"></span><br><span class="line">flex-grow：定义了项目的放大比例，默认为<span class="number">0</span>，即使存在剩余空间，也不放大。</span><br><span class="line"></span><br><span class="line">flex-shrink：定义了项目的缩小比例，默认为<span class="number">1</span>，即如果空间不足，该项目将缩小。</span><br><span class="line"></span><br><span class="line">flex-basis：定义在分配多余空间之前，项目占据的主轴空间。默认值为auto</span><br><span class="line"><span class="attr">flex</span>: <span class="number">1</span> 代表 <span class="number">1</span> <span class="number">1</span> auto</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>).<span class="property">BFC</span>是什么</span><br><span class="line"><span class="variable constant_">BFC</span> 全称：<span class="title class_">Block</span> <span class="title class_">Formatting</span> <span class="title class_">Context</span>， 名为 <span class="string">&quot;块级格式化上下文&quot;</span></span><br><span class="line"><span class="variable constant_">BFC</span>规则:</span><br><span class="line"><span class="variable constant_">BFC</span>就是一个块级元素，块级元素会在垂直方向一个接一个的排列</span><br><span class="line"><span class="variable constant_">BFC</span>就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签</span><br><span class="line">垂直方向的距离由margin决定， 属于同一个<span class="variable constant_">BFC</span>的两个相邻的标签外边距会发生重叠</span><br><span class="line">计算<span class="variable constant_">BFC</span>的高度时，浮动元素也参与计算</span><br><span class="line"><span class="variable constant_">BFC</span>作用:</span><br><span class="line"><span class="number">1.</span>在一个<span class="variable constant_">BFC</span>中，盒子会从包含块的顶部开始，在垂直方向上会一个挨着一个摆放，可能很多人都对这一点习以为常，但这点是<span class="variable constant_">BFC</span>帮助我们实现的。当我们对某个盒子设置一个margin-top的时候，<span class="variable constant_">BFC</span>会帮助我们解析，然后会在盒子布局时候给一个上边距</span><br><span class="line"><span class="number">2.</span>在一个<span class="variable constant_">BFC</span>中，每个元素的左边缘都会紧贴着包含块的左边缘</span><br><span class="line"><span class="number">3.</span>在同一个<span class="variable constant_">BFC</span>中，在垂直方向上，相邻两个盒子的margin会重叠，值取两者中较大的(可以利用此特性解决margin重叠问题)</span><br><span class="line">实现<span class="variable constant_">BFC</span>的方法</span><br><span class="line"><span class="number">1.</span> 浮动元素，float 除 none 以外的值</span><br><span class="line"><span class="number">2.</span> 定位元素，position的值不是<span class="keyword">static</span>或者relative。</span><br><span class="line"><span class="number">3.</span> display 为 inline-block flex grid</span><br><span class="line"><span class="number">4.</span> overflow hidden</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">4</span>).本地存储<span class="variable language_">localStorage</span> 和 sessionStorage的区别</span><br><span class="line"><span class="comment">// 1. 生命周期 一个是永久存在， 一个是关掉页面就不存在了（sessionStorage）</span></span><br><span class="line"><span class="comment">// 2. 数据共享  localStorage 多个窗口数据共享的（同一个浏览器同一个地址）， sessionStorage 只在当前窗口下数据共享</span></span><br><span class="line"><span class="comment">// 3. 他们的大小都是5M</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">5</span>).<span class="property">CSS</span>水平垂直居中</span><br><span class="line"><span class="number">1.</span>flex (父盒子上添加下面属性)</span><br><span class="line">    <span class="attr">display</span>: flex;</span><br><span class="line">    justify-<span class="attr">content</span>: center;</span><br><span class="line">    align-<span class="attr">items</span>: center;</span><br><span class="line"><span class="number">2.</span>子绝父相 + 负margin</span><br><span class="line">  <span class="comment">// 父元素 相对定位 relative</span></span><br><span class="line">明确子元素的宽高</span><br><span class="line"> <span class="comment">// 子元素 绝对定位</span></span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">    margin-<span class="attr">top</span>: -50px;</span><br><span class="line">    margin-<span class="attr">left</span>: -50px;</span><br><span class="line"><span class="number">3.</span>子绝父相 + transform</span><br><span class="line"><span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">50</span>%;</span><br><span class="line">    <span class="attr">transform</span>: <span class="title function_">translate</span>(-<span class="number">50</span>%, -<span class="number">50</span>%);</span><br><span class="line"><span class="number">4.</span>子绝父相 + left/right/top/<span class="attr">bottom</span>:<span class="number">0</span> + <span class="attr">margin</span>: auto;</span><br><span class="line">/ 父元素相对定位 relative</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子元素</span></span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attr">margin</span>: auto;</span><br><span class="line"><span class="number">5.</span>子绝父相 + <span class="title function_">calc</span>()</span><br><span class="line">子元素的宽高</span><br><span class="line">.<span class="property">parent</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">child</span> &#123;</span><br><span class="line">    <span class="attr">position</span>: absolute;</span><br><span class="line">    <span class="attr">top</span>: <span class="title function_">calc</span>(<span class="number">50</span>% - 50px);</span><br><span class="line">    <span class="attr">left</span>: <span class="title function_">calc</span>(<span class="number">50</span>% - 50px);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">6.</span>gird 网格布局</span><br><span class="line">.<span class="property">parent</span> &#123;</span><br><span class="line">    <span class="attr">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line">.<span class="property">child</span> &#123;</span><br><span class="line">   align-<span class="attr">self</span>: center;</span><br><span class="line">   justify-<span class="attr">self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">6</span>).标准盒模型和<span class="variable constant_">IE</span>盒模型的区别</span><br><span class="line">盒模型都是由四个部分组成的，分别是margin、border、padding 和 content。即外边距，边框，内边距，内容</span><br><span class="line">  标准盒模型</span><br><span class="line"><span class="number">1.</span>box-<span class="attr">sizing</span>: content-box 表示标准盒模型（默认值）</span><br><span class="line"><span class="number">2.</span>标准盒模型在计算宽高的时候只计算 content 内容的宽高，不包含内外边距以及边框的宽高</span><br><span class="line"><span class="number">3.</span>当标准盒模型的宽高确认时，增加内外边距和边框会撑大原盒子。</span><br><span class="line">  width = 内容的width</span><br><span class="line">  <span class="variable constant_">IE</span>盒模型</span><br><span class="line"><span class="number">1.</span>box-<span class="attr">sizing</span>: border-box 表示<span class="variable constant_">IE</span>盒模型（怪异盒模型）</span><br><span class="line"><span class="number">2.</span>怪异盒模型在计算宽高时包含 conntent 内容、padding内边距、border边框的宽高。</span><br><span class="line"><span class="number">3.</span>当怪异盒模型的宽高确认时，给怪异盒模型添加内边距和边框，怪异盒模型的宽高不会改变，而是通过向内压缩，挤压 content 内容的宽高实现。 </span><br><span class="line">  width = 内容的width + padding + border</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">7</span>).关于flex上的其他属性</span><br><span class="line">## 基本讲解</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> flex容器中存在两条轴，水平主轴盒垂直交叉轴（默认）</span><br><span class="line"><span class="number">2.</span> 容器中每个单元块被称之为flex item,每个项目占据的主轴空间（main size),占据交叉轴的空间为cross size</span><br><span class="line"></span><br><span class="line">## 用在父元素上的属性</span><br><span class="line"></span><br><span class="line">justify-content：space-around space-between  space-evently  center  flex-end</span><br><span class="line"></span><br><span class="line">align-<span class="attr">items</span>:flex-star flex-end</span><br><span class="line"></span><br><span class="line">flex-direction :row  row-reverse  column  column-reverse</span><br><span class="line"></span><br><span class="line">flex-wrap :nowrap（如果子孩子，的宽度超过父盒子，会进行总动的伸缩） wrap（不去管）</span><br><span class="line"></span><br><span class="line">## 用在子元素上的属性</span><br><span class="line"></span><br><span class="line">order （项目排列的顺序 越小越靠前）</span><br><span class="line"></span><br><span class="line">align-self（单个属性的操作 flex-end center flex-star）</span><br><span class="line"></span><br><span class="line">flex-grow（如果剩余有宽度是否进行扩张方法，默认是<span class="number">0</span>，）</span><br><span class="line"></span><br><span class="line">flex-shrink （空间不足的时候进行缩小默认是<span class="number">1</span> 进行缩小</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">8</span>).伪元素和伪类的区别</span><br><span class="line">伪类:</span><br><span class="line">伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候</span><br><span class="line">伪类就是开头为冒号的关键字：  比如 hover  focus </span><br><span class="line">伪元素:</span><br><span class="line">伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 <span class="variable constant_">HTML</span> 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::</span><br><span class="line">比如before 在元素的前面添加  after  在元素的后面添加</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">9</span>).回流和重绘</span><br><span class="line">浏览器解析渲染机制</span><br><span class="line">解析<span class="variable constant_">HTML</span>，生成<span class="variable constant_">DOM</span>树，解析<span class="variable constant_">CSS</span>，生成<span class="variable constant_">CSSOM</span>树</span><br><span class="line">将<span class="variable constant_">DOM</span>树和<span class="variable constant_">CSSOM</span>树结合，生成渲染树(<span class="title class_">Render</span> <span class="title class_">Tree</span>)</span><br><span class="line"><span class="title class_">Layout</span>(回流):根据生成的渲染树，进行回流(<span class="title class_">Layout</span>)，得到节点的几何信息（位置，大小）</span><br><span class="line"><span class="title class_">Painting</span>(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</span><br><span class="line"><span class="title class_">Display</span>:将像素发送给<span class="variable constant_">GPU</span>，展示在页面上</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">回流：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置</span><br><span class="line">重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制</span><br><span class="line"></span><br><span class="line">回流触发的情况</span><br><span class="line">添加或删除可见的<span class="variable constant_">DOM</span>元素</span><br><span class="line">元素的位置发生变化</span><br><span class="line">元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</span><br><span class="line">内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代</span><br><span class="line">页面一开始渲染的时候（这避免不了）</span><br><span class="line">浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的</span><br><span class="line"></span><br><span class="line">重绘触发的情况</span><br><span class="line">触发回流一定会触发重绘</span><br><span class="line">颜色的修改</span><br><span class="line">文本方向的修改</span><br><span class="line">阴影的修</span><br><span class="line"></span><br><span class="line">结论: 回流一定引起重绘, 重绘不一定引起回流</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).结构伪类选择器</span><br><span class="line"><span class="attr">selector</span>:first-child 用来定位一组兄弟元素中的第一个元素</span><br><span class="line"><span class="attr">selector</span>:last-child用来定位一组兄弟元素中的最后一个元素</span><br><span class="line"><span class="attr">selector</span>:nth-<span class="title function_">child</span>(n)用来定位一组兄弟元素中的第 n 个元素</span><br><span class="line"><span class="attr">selector</span>:nth-last-<span class="title function_">child</span>(n)用来定位一组兄弟元素中倒序方式的第 n 个元素</span><br><span class="line"><span class="attr">selector</span>:first-<span class="keyword">of</span>-type用来定位一组同类型的兄弟元素中的第一个元素</span><br><span class="line"><span class="attr">selector</span>:last-<span class="keyword">of</span>-type用来定位一组同类型的兄弟元素中的最后一个元素</span><br><span class="line"><span class="attr">selector</span>:nth-<span class="keyword">of</span>-<span class="title function_">type</span>(n)用来定位一组同类型的兄弟元素中的第 n 个元素</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">11</span>).<span class="property">line</span>-height <span class="number">150</span>% 和 line-<span class="attr">height</span>: <span class="number">1.5</span>的区别</span><br><span class="line">父元素设置line-<span class="attr">height</span>:<span class="number">1.5</span>会直接继承给子元素，子元素根据自己的font-size</span><br><span class="line">再去计算子元素自己的line-height。</span><br><span class="line">父元素设置line-<span class="attr">height</span>:<span class="number">150</span>%是计算好了line-height值，</span><br><span class="line">然后把这个计算值给子元素继承，子元素继承拿到的就是最终的值了。</span><br><span class="line">此时子元素设置font-size就对其line-height无影响了</span><br><span class="line"></span><br><span class="line"><span class="attr">eg</span>:</span><br><span class="line">例<span class="number">1</span>：当line-<span class="attr">height</span>:<span class="number">1.5</span> 时：</span><br><span class="line">body&#123; font-<span class="attr">size</span>:14px; line-<span class="attr">height</span>:<span class="number">1.5</span>; &#125;</span><br><span class="line">h1&#123; font-<span class="attr">size</span>:26px; &#125;</span><br><span class="line">实际结果为：</span><br><span class="line">body的行高为<span class="number">14</span>*<span class="number">1.5</span>=21px</span><br><span class="line">h1的行高为<span class="number">26</span>*<span class="number">1.5</span>=39px</span><br><span class="line">例<span class="number">2</span>：当line-<span class="attr">height</span>:<span class="number">150</span>% 时：</span><br><span class="line">body&#123; font-<span class="attr">size</span>:14px; line-<span class="attr">height</span>:<span class="number">150</span>%; &#125;</span><br><span class="line">h1&#123; font-<span class="attr">size</span>:26px; &#125;</span><br><span class="line">实际结果为：</span><br><span class="line">body的行高为<span class="number">14</span>*<span class="number">150</span>%=21px</span><br><span class="line">h1的行高为直接继承body的行高，为21px</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">12</span>).什么是原型</span><br><span class="line">原型就是一个对象,也叫做原型对象</span><br><span class="line"><span class="number">1.</span>每个函数都有prototype属性,它的值是一个指针,指向的就是原型对象</span><br><span class="line"><span class="number">2.</span>通过构造函数生成的实例,都有一个__proto__属性,也指向原型对象</span><br><span class="line"><span class="number">3.</span>原型上默认有一个constructor属性,指回构造函数</span><br><span class="line">原型的作用</span><br><span class="line"><span class="number">1.</span>可以把一些公共的属性和方法放到原型上</span><br><span class="line"><span class="number">2.</span>通过构造函数创建的实例,都共享原型上的属性和方法</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">13</span>) 原型链的理解</span><br><span class="line"><span class="number">1.</span>正常的原型链都会终止于<span class="title class_">Object</span>的原型对象或终止于<span class="literal">null</span></span><br><span class="line"><span class="number">2.</span>每个对象通过__proto__都可以访问到它的原型,原型也有它的原型</span><br><span class="line"><span class="number">3.</span>当访问一个对象的属性和方法时,先在自身中查找,如果没有,就会沿着</span><br><span class="line">__proto__这条链,往上查找,一直找到最顶层</span><br><span class="line"></span><br><span class="line">数组的原型链</span><br><span class="line">arr --&gt; <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br><span class="line">函数的原型链</span><br><span class="line">fn --&gt; <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> --&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">14</span>) 数据类型</span><br><span class="line">数据的类型</span><br><span class="line"><span class="number">1.</span>基本数据类型: <span class="title class_">Number</span> <span class="title class_">String</span> <span class="title class_">Boolean</span> <span class="literal">undefined</span> <span class="literal">null</span> <span class="title class_">Symbol</span> <span class="title class_">BigInt</span></span><br><span class="line"><span class="number">2.</span>引用类型: <span class="title class_">Object</span> ==&gt; <span class="title class_">Function</span> <span class="title class_">Array</span> <span class="title class_">Date</span> <span class="title class_">Math</span> <span class="title class_">RegExp</span>(正则)</span><br><span class="line">基本数据类型和引用数据类型在内存中的存储</span><br><span class="line">栈(<span class="title class_">Stack</span>): 基本数据类型的值,存在栈里面的</span><br><span class="line">堆(<span class="title class_">Heap</span>): 引用类型的数据,栈里面存放的是地址,这个地址指向堆中的数据</span><br><span class="line">注意点:</span><br><span class="line">栈空间 有后进先出的特点(后存放的数据放在最上面)</span><br><span class="line">基本数据类型 不可以添加属性和方法</span><br><span class="line"><span class="attr">eg</span>: <span class="keyword">let</span> str = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">str.<span class="property">a</span> = <span class="string">&#x27;222&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">a</span>) <span class="comment">//undefined</span></span><br><span class="line">基本数据类型是按值访问的(操作的是存储在变量中的实际值)</span><br><span class="line">引用类型,直接赋值,实际上是复制的地址</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">15</span>)浅拷贝</span><br><span class="line">浅拷贝: 在堆内存中开辟一个新的内存空间,创建一个新对象</span><br><span class="line">拷贝原对象的第一层,基本数据类型的值和引用类型的地址</span><br><span class="line">拷贝基本数据类型, 拷贝后两个对象相互不影响</span><br><span class="line">修改引用类型的属性值,相互影响</span><br><span class="line">实现浅拷贝的方式</span><br><span class="line"><span class="number">1.</span><span class="title class_">Object</span>.<span class="title function_">assign</span>()   <span class="keyword">const</span> newObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj)</span><br><span class="line"><span class="number">2.</span>扩展运算符          <span class="keyword">const</span> newObj = [...obj]</span><br><span class="line"><span class="number">3.</span>数组的<span class="title function_">concat</span>()     <span class="keyword">const</span> newArr = arr.<span class="title function_">concat</span>()</span><br><span class="line"><span class="number">4.</span>数组的<span class="title function_">slice</span>()      <span class="keyword">const</span> newArr = arr.<span class="title function_">slice</span>()</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">16</span>) 深拷贝</span><br><span class="line">深拷贝:在堆内存中开辟一个新空间存放新对象, 递归的拷贝原对象的所有属性和方法, 拷贝前后两个对象,相互不影响</span><br><span class="line">实现深拷贝的方式</span><br><span class="line"><span class="number">1.</span><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line"><span class="number">2.</span>手写递归实现</span><br><span class="line"><span class="number">3.</span> 使用一些<span class="variable constant_">JS</span>库，比如lodash等 </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">17</span>) 箭头函数的特点</span><br><span class="line"><span class="number">1.</span>箭头函数没有prototype属性,也没有原型</span><br><span class="line"><span class="number">2.</span>不能使用<span class="keyword">new</span> 调用箭头函数 ==&gt; 箭头函数不能作为构造函数</span><br><span class="line"><span class="number">3.</span>箭头函数没有<span class="variable language_">arguments</span> 可以使用剩余参数接收参数 </span><br><span class="line"><span class="number">4.</span>箭头函数本身没有<span class="variable language_">this</span> </span><br><span class="line">箭头函数的<span class="variable language_">this</span>指向在定义的时候就确定了,指向的是上层作用域中的<span class="variable language_">this</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">18</span>)<span class="keyword">let</span>/<span class="keyword">const</span>/<span class="keyword">var</span>的区别</span><br><span class="line"><span class="number">1.</span><span class="keyword">let</span>/<span class="keyword">const</span> 可以形成块级作用域,<span class="keyword">var</span> 不可以</span><br><span class="line"><span class="number">2.</span><span class="keyword">let</span>/<span class="keyword">const</span> 是不存在变量提升的 <span class="keyword">var</span> 可以   ??</span><br><span class="line"><span class="number">3.</span><span class="keyword">let</span>/<span class="keyword">const</span> 不能重复声明, <span class="keyword">var</span> 可以</span><br><span class="line"><span class="number">4.</span><span class="keyword">let</span>/<span class="keyword">const</span> 不能在声明之前使用(暂时性死区), <span class="keyword">var</span> 可以</span><br><span class="line"><span class="number">5.</span><span class="keyword">const</span> 声明的时候,必须马上赋值</span><br><span class="line"><span class="number">6.</span><span class="keyword">let</span>/<span class="keyword">const</span> 在全局作用域上声明不会挂载到<span class="variable language_">window</span>上, <span class="keyword">var</span> 可以</span><br><span class="line"><span class="number">7.</span><span class="keyword">const</span> 声明的变量不能改变值 （简单类型值，引用类型不能改变地址）</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">19</span>)垃圾回收机制</span><br><span class="line">垃圾回收机制: <span class="variable constant_">JS</span>中内存的分配和回收是自动的, 当内存在不被使用的时候会被<span class="variable constant_">JS</span>引擎自动回收</span><br><span class="line">全局的变量: 会在页面关闭的时候回收</span><br><span class="line">局部的变量: 块级作用域是执行一次,回收一次 在函数被调用完毕的时候,就会被回收</span><br><span class="line">引用计数法:</span><br><span class="line"><span class="number">1.</span>跟踪记录每个值被引用的次数</span><br><span class="line"><span class="number">2.</span>如果这个值被引用一次,就记录一次</span><br><span class="line"><span class="number">3.</span>多次引用会累加</span><br><span class="line"><span class="number">4.</span>如果减少一次引用就会减少一次</span><br><span class="line"><span class="number">5.</span>如果引用次数是<span class="number">0</span>,则释放内存</span><br><span class="line">缺陷:</span><br><span class="line">堆内存空间的对象,如果相互引用,计数永远不能为<span class="number">0</span>,无法被回收,就存在内存泄漏</span><br><span class="line">标记清除法:</span><br><span class="line"><span class="number">1.</span>标记阶段: 标记空间中的活动对象和非活动对象</span><br><span class="line"><span class="number">2.</span>清除阶段: 回收非活动对象</span><br><span class="line"></span><br><span class="line">标记阶段从一组根元素开始</span><br><span class="line">递归遍历(一层一层的)这组根元素</span><br><span class="line">在遍历的过程中,能访问到的元素称为活动对象, 不能访问到的可以判断为垃圾数据(非活动对象)</span><br><span class="line"></span><br><span class="line">缺陷:内存碎片化</span><br><span class="line">解决:标记整理算法</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">20</span>)闭包</span><br><span class="line">闭包: 内层函数引用外层函数中的变量的集合</span><br><span class="line">作用:</span><br><span class="line"><span class="number">1.</span>可以让外部作用域访问到函数内部的变量</span><br><span class="line"><span class="number">2.</span>实现数据私有化</span><br><span class="line">闭包产生的问题:</span><br><span class="line"><span class="number">1.</span> 本来i是函数内部的一个局部变量，按理说我们，当我们调用完<span class="title function_">count</span>()之后，应该释放掉这个变量</span><br><span class="line"><span class="number">2.</span> 但是这里，每次调用fn的时候，一直都能访问到这个i变量， i一直没有被回收。</span><br><span class="line"><span class="number">3.</span>i本来应该被回收，但是没有释放，所以会造成内存泄漏</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">21</span>)改变<span class="variable language_">this</span>的方法 call/apply/bind的区别</span><br><span class="line">call/apply/bind的区别</span><br><span class="line"><span class="number">1.</span>都能改变<span class="variable language_">this</span>指向</span><br><span class="line"><span class="number">2.</span>call,bind接收的是参数列表,apply接收的是数组</span><br><span class="line"><span class="number">3.</span>call和apply是立即执行的,bind返回一个函数,需要手动调用</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">22</span>)<span class="variable language_">this</span>的指向</span><br><span class="line"><span class="variable language_">this</span>指向在定义的时候不能明确,只有调用执行的时候才能明确</span><br><span class="line"><span class="number">1.</span> 全局作用域 / 普通函数调用 / 定时器 <span class="variable language_">this</span>指向的是<span class="variable language_">window</span></span><br><span class="line"><span class="number">2.</span> 作为对象的方法调用时,谁调用这个方法,<span class="variable language_">this</span>指向谁</span><br><span class="line"><span class="number">3.</span> 注册事件的时候,<span class="variable language_">this</span>指向被绑定的元素</span><br><span class="line"><span class="number">4.</span> 构造函数中,<span class="variable language_">this</span>指向的是实例对象</span><br><span class="line"><span class="number">5.</span> 原型方法里面,<span class="variable language_">this</span>指向的是实例</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">23</span>)实现继承的方式  原型链的继承</span><br><span class="line"><span class="number">1.</span>原型链继承 <span class="number">2.</span>借助构造函数 <span class="number">3.</span>组合继承 <span class="number">4.</span>原型式继承 <span class="number">5.</span>寄生式继承</span><br><span class="line"><span class="number">6.</span>寄生式组合继承(推荐) <span class="number">7.</span><span class="title class_">ES6</span>中<span class="keyword">extends</span> 继承</span><br><span class="line"></span><br><span class="line">继承: 子类拥有父类的属性和方法</span><br><span class="line">继承的核心: 让子类的原型 等于父级构造函数的实例</span><br><span class="line">优点: 方法复用,共享 因为方法定义在父类的原型上,实例共享了父类原型上的方法</span><br><span class="line">缺点:</span><br><span class="line"><span class="number">1.</span>子类在实例化的时候,不能给父类构造函数传参</span><br><span class="line"><span class="number">2.</span>子类的实例共享了父类构造函数的属性和方法</span><br><span class="line">如果父类里的属性值是引用类型, 实例修改这个值后会相互影响</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">24</span>)防抖</span><br><span class="line">防抖:debounce </span><br><span class="line">当持续触发事件时,一定时间内没有再触发事件,回调函数才会执行一次</span><br><span class="line">如果设定的延时时间到来之前,又触发了事件,就重新计时</span><br><span class="line">应用场景</span><br><span class="line"><span class="number">1.</span>搜索框输入查询的时候</span><br><span class="line"><span class="number">2.</span>鼠标连续点击按钮提交等</span><br><span class="line">手写防抖</span><br><span class="line"><span class="number">1.</span>获取元素</span><br><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"><span class="number">2.</span>封装一个函数,当键盘抬起时,执行函数</span><br><span class="line"><span class="keyword">const</span> sendMsg = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发起请求&#x27;</span>)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//input</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>封装一个debounce防抖函数来操作sendMsg这个函数,等待300ms才执行</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, ms = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> timer <span class="comment">//作为清除定时器的id 这里是在绑定事件的时候就执行了,执行一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>)&#123; <span class="comment">// args 剩余参数 是一个真数组 这里展开了</span></span><br><span class="line">        <span class="comment">//return function的外层,它绑定keyup的时候就立即执行了,只能执行一次</span></span><br><span class="line">        <span class="comment">//return function的里面,每次触发keyup的时候,才执行,只要触发就执行</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)<span class="comment">// 如果存在定时器,先清除,让整个程序只有一个定时器执行</span></span><br><span class="line">        <span class="comment">//第一次清除的话是undefined</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// input</span></span><br><span class="line">       timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// input 这里不写成箭头函数的话this指向window</span></span><br><span class="line">           <span class="comment">//箭头函数本身没有this,this指向的是上层作用域中的this</span></span><br><span class="line">           fn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args) <span class="comment">//这里的fn就是sendMsg  这里也可以用apply 参数为数组</span></span><br><span class="line">           <span class="comment">//fn() 这个函数是window调用的 this指向window,这个函数一直都是window在调用</span></span><br><span class="line">           <span class="comment">// 换成箭头函数后, 还是window在调用</span></span><br><span class="line">       &#125;,ms)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span>注册事件</span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="title function_">debounce</span>(sendMsg, <span class="number">300</span>).<span class="title function_">bind</span>(input, <span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment">// 正常情况下, 事件监听的第二个参数,是一个函数声明,这里添加了小括号表示立即调用执行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">25</span>)节流</span><br><span class="line">节流: throttle</span><br><span class="line">持续的触发事件,在一段时间内,只允许函数执行一次</span><br><span class="line"> ==&gt; 减少一段时间内,事件触发的频率</span><br><span class="line">应用场景</span><br><span class="line"><span class="number">1.</span>浏览器窗口缩放, resize事件</span><br><span class="line"><span class="number">2.</span>scroll滚动事件 / mousemove 事件</span><br><span class="line">手写节流</span><br><span class="line">(<span class="number">1</span>)时间戳版本</span><br><span class="line"><span class="number">1.</span>获取元素</span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="number">2.</span>封装一个函数</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">move</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  box.<span class="property">innerHTML</span> = i++</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>封装一个节流函数, 隔500ms执行一次</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, ms = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">let</span> prev = <span class="number">0</span></span><br><span class="line">   <span class="comment">//记录一个开始时间</span></span><br><span class="line">   <span class="comment">//获取mousemove时间触发的时间</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...arges</span>)&#123;</span><br><span class="line">     <span class="keyword">let</span> now = + <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">     <span class="keyword">if</span>(now - prev &gt;= ms)&#123;</span><br><span class="line">         fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arges)</span><br><span class="line">         prev = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span>事件绑定</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">throttle</span>(move, <span class="number">500</span>))</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)定时器版</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, ms = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">             <span class="keyword">let</span> timer </span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">// 如果没有定时器, 就开启定时器</span></span><br><span class="line">                <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">                    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 箭头函数没有arguments,往上层找</span></span><br><span class="line">                        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">                        <span class="comment">// 这里,让下一次定时器又可以开启</span></span><br><span class="line">                        timer = <span class="number">0</span></span><br><span class="line">                    &#125;, ms)</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="title function_">throttle</span>(move, <span class="number">500</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">26</span>)现在有一段字符串，要求统计字符串种出现的字符和次数</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">&#x27;ashdkahsfukaysduiqewke&#x27;</span></span><br><span class="line">        <span class="comment">// 字符串也有下标和长度,可以使用for进行遍历</span></span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 第一次出现的时候,将对象的值赋值为1</span></span><br><span class="line">            <span class="keyword">if</span>(!obj[str[i]])&#123;</span><br><span class="line">                obj[str[i]] = <span class="number">1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 存在就让数量加1</span></span><br><span class="line">                obj[str[i]]++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 方案二</span></span><br><span class="line">            <span class="comment">// 用当前字符进行分隔</span></span><br><span class="line">            <span class="comment">// obj[str[i]] = str.split(str[i]).length - 1</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">27</span>) <span class="number">2.</span>请用最优方法输出长度为<span class="number">500</span>的数组内容为：[<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;N&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;U&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="string">&quot;AA&quot;</span>, <span class="string">&quot;AB&quot;</span>, <span class="string">&quot;AC&quot;</span>, <span class="string">&quot;AD&quot;</span>, <span class="string">&quot;AE&quot;</span>, <span class="string">&quot;AF&quot;</span>, <span class="string">&quot;AG&quot;</span>, <span class="string">&quot;AH&quot;</span>, <span class="string">&quot;AI&quot;</span>, <span class="string">&quot;AJ&quot;</span>, <span class="string">&quot;AK&quot;</span>, <span class="string">&quot;AL&quot;</span>, <span class="string">&quot;AM&quot;</span>, <span class="string">&quot;AN&quot;</span>, <span class="string">&quot;AO&quot;</span>, <span class="string">&quot;AP&quot;</span>, <span class="string">&quot;AQ&quot;</span>, <span class="string">&quot;AR&quot;</span>, <span class="string">&quot;AS&quot;</span>, <span class="string">&quot;AT&quot;</span>, <span class="string">&quot;AU&quot;</span>, <span class="string">&quot;AV&quot;</span>, <span class="string">&quot;AW&quot;</span>, <span class="string">&quot;AX&quot;</span>, <span class="string">&quot;AY&quot;</span>, <span class="string">&quot;AZ&quot;</span>, <span class="string">&quot;BA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;BC&quot;</span>, <span class="string">&quot;BD&quot;</span>, <span class="string">&quot;BE&quot;</span>, <span class="string">&quot;BF&quot;</span>, <span class="string">&quot;BG&quot;</span>, <span class="string">&quot;BH&quot;</span>, <span class="string">&quot;BI&quot;</span>, <span class="string">&quot;BJ&quot;</span>, <span class="string">&quot;BK&quot;</span>, <span class="string">&quot;BL&quot;</span>, <span class="string">&quot;BM&quot;</span>, <span class="string">&quot;BN&quot;</span>, <span class="string">&quot;BO&quot;</span>, <span class="string">&quot;BP&quot;</span>, <span class="string">&quot;BQ&quot;</span>, <span class="string">&quot;BR&quot;</span>, <span class="string">&quot;BS&quot;</span>, <span class="string">&quot;BT&quot;</span>, <span class="string">&quot;BU&quot;</span>, <span class="string">&quot;BV&quot;</span>, <span class="string">&quot;BW&quot;</span>, <span class="string">&quot;BX&quot;</span>, <span class="string">&quot;BY&quot;</span>, <span class="string">&quot;BZ&quot;</span>, <span class="string">&quot;CA&quot;</span>, <span class="string">&quot;CB&quot;</span>]...	根据字符编码<span class="number">65</span>——<span class="number">91</span>对应了A——Z，以下函数可以获得一个[A,B,C...Y,Z]数组</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getEN</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> arr = [];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">65</span>; i &lt; <span class="number">91</span>; i++) &#123;</span><br><span class="line">                arr.<span class="title function_">push</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> newArr = <span class="title function_">getEN</span>()</span><br><span class="line">        <span class="keyword">const</span> sumArr = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> resArr = []</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">26</span>) &#123;</span><br><span class="line">                    resArr.<span class="title function_">push</span>(newArr[i])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当i &gt;= 26 是 通过 i / 26 取整减一得到第一个字母  第二个字母通过取余获得</span></span><br><span class="line">                    str = newArr[<span class="built_in">parseInt</span>(i / <span class="number">26</span>) - <span class="number">1</span>] + newArr[i % <span class="number">26</span>]</span><br><span class="line">                    resArr.<span class="title function_">push</span>(str)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> resArr</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sumArr</span>())</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">28</span>)数组扁平化 <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]]]]，将数组arr转变成[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, [<span class="number">8</span>, <span class="number">9</span>]]]]</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">resArr</span>(<span class="params">oldArr</span>)&#123;</span><br><span class="line">            <span class="keyword">let</span> newArr = []</span><br><span class="line">            <span class="keyword">for</span>(k <span class="keyword">in</span> oldArr)&#123;</span><br><span class="line">                <span class="keyword">if</span>(oldArr[k] <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">                    <span class="comment">// newArr.push(...resArr(oldArr[k]))</span></span><br><span class="line">                    newArr = newArr.<span class="title function_">concat</span>(<span class="title function_">resArr</span>(oldArr[k]))</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    newArr.<span class="title function_">push</span>(oldArr[k])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newArr</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">resArr</span>(arr))</span><br><span class="line">        <span class="comment">// 方案二</span></span><br><span class="line">        <span class="keyword">const</span> newArr = arr.<span class="title function_">flat</span>(<span class="number">3</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">29</span>)css中使用inline-block后,会存在间隙</span><br><span class="line">当我们想把两个块元素的设置<span class="attr">display</span>:inline-block;使得两个块元素显示子在一行时候，我们会发现块元素和块元素的之间存在一定的空隙。这就是“换行符/空格间隙问题”</span><br><span class="line">元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据white-space的处理方式（默认是normal，合并多余空白），原来<span class="variable constant_">HTML</span>代码中的回车换行被转成一个空白符，在字体不为<span class="number">0</span>的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-<span class="attr">size</span>:16px时，间距为8px。</span><br><span class="line">解决间隙的方法</span><br><span class="line">(<span class="number">1</span>)将所有的标签写在同一行</span><br><span class="line">(<span class="number">2</span>)给父元素设置font-size为<span class="number">0</span>,再重新给子元素设置字体大小</span><br><span class="line">(<span class="number">3</span>)给父级添加<span class="attr">display</span>: flex</span><br><span class="line">(<span class="number">4</span>)设置子元素margin为负值</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/08/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clcn2azv90000t4vy48m7eyqw" class="article-share-link">
        Share
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  
  <a href="/2023/01/07/%E6%98%8E%E5%A4%A9%E5%87%86%E5%A4%87%E5%90%83%E4%BB%80%E4%B9%88/" class="article-nav-link">
    <strong class="article-nav-caption">Older</strong>
    <div class="article-nav-title">明天准备吃什么</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>Hexo &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>